{"version":3,"sources":["Triangulation.js","serviceWorkerRegistration.js","reportWebVitals.js","index.js"],"names":["canvasWidth","window","innerWidth","canvasHeight","innerHeight","valueToPercent","percent","min","max","generateColorVariant","hexcolor","tint","shade","rgb","colorConvertor","hex","r","g","b","pointsOfTriangle","delauney","i","edgesOfTriangle","map","e","triangles","Triangulation","props","topColor","hsv","topcolor","topHue","topSat","topLig","botColor","botcolor","botHue","botSat","botLig","pointsColor","pointscolor","minCircleSize","mincirclesize","maxCircleSize","maxcirclesize","colorVariance","colorvariance","tintFactor","shadeFactor","particleAmount","count","particleMinSpeed","minspeed","particleMaxSpeed","maxspeed","pointShadowBlur","pointshadowblur","pointShadowColor","pointshadowcolor","fps","backgroundColor","backgroundcolor","lineWidth","linewidth","lineColor","linecolor","triangleShadowBlur","triangleshadowblur","triangleShadowColor","triangleshadowcolor","useState","particles","setParticles","canvasRef","useRef","canvas","ctx","useEffect","init","addEventListener","cancelAnimationFrame","loop","addParticle","x","y","particleArray","amplitude","Math","random","angle","PI","radius","push","velocityX","cos","velocityY","sin","circleSize","circleColor","requestAnimationForFirstTime","current","getContext","particlesLocal","setTimeout","requestAnimationFrame","save","fillStyle","fillRect","restore","particle","particlesForDelaunator","Object","values","delaunator","Delaunator","from","drawTriangle","triangle","beginPath","moveTo","lineTo","closePath","generateColor","shadowColor","shadowBlur","fill","strokeStyle","stroke","length","arc","ax","ay","bx","by","cx","cy","percentDistanceFromFloor","hue","sat","lig","hsl","ref","style","position","zIndex","width","height","isLocalhost","Boolean","location","hostname","match","registerValidSW","swUrl","config","navigator","serviceWorker","register","then","registration","onupdatefound","installingWorker","installing","onstatechange","state","controller","console","log","onUpdate","onSuccess","catch","error","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","document","getElementById","URL","process","href","origin","fetch","headers","response","contentType","get","status","indexOf","ready","unregister","reload","checkValidServiceWorker","serviceWorkerRegistration"],"mappings":"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","file":"static/js/main.b1e62498.chunk.js","sourcesContent":["import { React, useState, useEffect, useRef } from 'react';\r\nimport Delaunator from 'delaunator';\r\nimport colorConvertor from 'color-convert';\r\n\r\n//global config\r\nlet canvasWidth = window.innerWidth;\r\nlet canvasHeight = window.innerHeight;\r\n\r\n//helper functions\r\nconst valueToPercent = (percent, min, max) => {\r\n    return min + percent * (max - min);\r\n}\r\nconst generateColorVariant = (hexcolor, tint, shade) => {\r\n    //https://github.com/edelstone/tints-and-shades\r\n    const rgb = colorConvertor.hex.rgb(hexcolor);\r\n    let r = rgb[0]; r = r + ((255 - r) * tint); r = r * shade;\r\n    let g = rgb[1]; g = g + ((255 - g) * tint); g = g * shade;\r\n    let b = rgb[2]; b = b + ((255 - b) * tint); b = b * shade;\r\n    return \"#\" + colorConvertor.rgb.hex(r, g, b);\r\n}\r\nconst edgesOfTriangle = (i) => {\r\n    return [3 * i, 3 * i + 1, 3 * i + 2];\r\n}\r\nconst pointsOfTriangle = (delauney, i) => {\r\n    return edgesOfTriangle(i).map(e => delauney.triangles[e]);\r\n}\r\n\r\n//main component\r\nconst Triangulation = (props) => {\r\n    //upper color\r\n    const topColor = colorConvertor.hex.hsv((props.topcolor) ? props.topcolor : \"#221A33\");\r\n    const topHue = topColor[0];\r\n    const topSat = topColor[1];\r\n    const topLig = topColor[2];\r\n\r\n    //bottom color\r\n    const botColor = colorConvertor.hex.hsv((props.botcolor) ? props.botcolor : \"#8A3D99\");\r\n    const botHue = botColor[0];\r\n    const botSat = botColor[1];\r\n    const botLig = botColor[2];\r\n\r\n    //points\r\n    const pointsColor = (props.pointscolor) ? props.pointscolor : \"#000000\";\r\n    const minCircleSize = (props.mincirclesize) ? props.mincirclesize : 3;\r\n    const maxCircleSize = (props.maxcirclesize) ? props.maxcirclesize : 8;\r\n    const colorVariance = (props.colorvariance) ? props.colorvariance : false;\r\n    const tintFactor = (props.tint) ? props.tint : 0;\r\n    const shadeFactor = (props.shade) ? props.shade : 1;\r\n\r\n    //particles config\r\n    const particleAmount = ((props.count) ? props.count : 100);\r\n    const particleMinSpeed = (props.minspeed) ? props.minspeed : 0.1;\r\n    const particleMaxSpeed = (props.maxspeed) ? props.maxspeed : 0.5;\r\n    const pointShadowBlur = (props.pointshadowblur) ? props.pointshadowblur : 3;\r\n    const pointShadowColor = (props.pointshadowcolor) ? props.pointshadowcolor : \"#000000\";\r\n\r\n    //global config\r\n    const fps = (props.fps) ? props.fps : 60;\r\n    const backgroundColor = (props.backgroundcolor) ? props.backgroundcolor : \"#00000000\";\r\n    const lineWidth = (props.linewidth) ? props.linewidth : 0.0;\r\n    const lineColor = (props.linecolor) ? props.linecolor : \"#00000000\";\r\n\r\n    //triangle config\r\n    const triangleShadowBlur = (props.triangleshadowblur) ? props.triangleshadowblur : 0;\r\n    const triangleShadowColor = (props.triangleshadowcolor) ? props.triangleshadowcolor : \"#00000000\";\r\n\r\n    //list of particles\r\n    let [particles, setParticles] = useState([]);\r\n\r\n    //canvas\r\n    let canvasRef = useRef();   //canvas reference\r\n    let canvas = null;          //canvas element\r\n    let ctx = null;             //canvas context\r\n\r\n    //executed only once - initialisation\r\n    useEffect(() => {\r\n        init(true); //first time init\r\n\r\n        //event - resize\r\n        window.addEventListener('resize', () => {\r\n            canvasHeight = window.innerHeight;\r\n            canvasWidth = window.innerWidth;\r\n            init(false); //init is not first time\r\n        });\r\n\r\n        //cleanup\r\n        return () => {\r\n            cancelAnimationFrame(loop);\r\n        }\r\n    }, []);\r\n\r\n    //add particles to the list\r\n    const addParticle = (x, y, particleArray) => {\r\n        const amplitude = Math.random() * (particleMaxSpeed - particleMinSpeed) + particleMinSpeed;\r\n        const angle = Math.random() * Math.PI * 2;\r\n        const radius = valueToPercent(Math.random(), minCircleSize, maxCircleSize);\r\n\r\n        particleArray.push({\r\n            x: x,\r\n            y: y,\r\n            velocityX: amplitude * Math.cos(angle),\r\n            velocityY: amplitude * Math.sin(angle),\r\n            circleSize: radius,\r\n            circleColor: (colorVariance) ? generateColorVariant(pointsColor, Math.random() * tintFactor, Math.random() * shadeFactor) : pointsColor\r\n        });\r\n    };\r\n\r\n    //initialiser function\r\n    const init = (requestAnimationForFirstTime) => {\r\n        canvas = canvasRef.current;\r\n        ctx = canvas.getContext('2d');\r\n        const particlesLocal = [];\r\n\r\n        //particles on the edges\r\n        particlesLocal.push({ x: 0, y: 0, velocityX: 0, velocityY: 0, circleSize: 0});\r\n        particlesLocal.push({ x: 0, y: canvasHeight, velocityX: 0, velocityY: 0, circleSize: 0 });\r\n        particlesLocal.push({ x: canvasWidth, y: 0, velocityX: 0, velocityY: 0, circleSize: 0 });\r\n        particlesLocal.push({ x: canvasWidth, y: canvasHeight, velocityX: 0, velocityY: 0, circleSize: 0 });\r\n\r\n        for(let i = 0; i < particleAmount; i++) {\r\n            addParticle(\r\n                Math.random() * canvasWidth,\r\n                Math.random() * canvasHeight,\r\n                particlesLocal\r\n            );\r\n        }\r\n\r\n        particles = particlesLocal;\r\n        setParticles(particlesLocal);\r\n\r\n        if(requestAnimationForFirstTime) {\r\n            setTimeout(() => {\r\n                requestAnimationFrame(loop);\r\n            }, 1000 / fps);\r\n        }\r\n    }\r\n\r\n    //loop function\r\n    const loop = () => {\r\n        //TODO save and restore optimisation?\r\n        ctx.save();\r\n        ctx.fillStyle = backgroundColor;\r\n        ctx.fillRect(0, 0, canvasWidth, canvasHeight);\r\n        ctx.restore();\r\n\r\n        //updating all particles\r\n        let updatedParticles = particles.map((particle, i) => {\r\n            let x = particle.x;\r\n            let y = particle.y;\r\n            let velocityX = particle.velocityX;\r\n            let velocityY = particle.velocityY;\r\n\r\n            x += velocityX;\r\n            y += velocityY;\r\n\r\n            //X axis bounce\r\n            if(x < 0) {\r\n                x = 0;\r\n                if(velocityX < 0) { velocityX *= -1; }\r\n            } else if(x > canvasWidth) {\r\n                x = canvasWidth;\r\n                if(velocityX > 0) { velocityX *= -1; }\r\n            }\r\n\r\n            //Y axis bounce\r\n            if(y < 0) {\r\n                y = 0;\r\n                if(velocityY < 0) { velocityY *= -1; }\r\n            } else if(y > canvasHeight) {\r\n                y = canvasHeight;\r\n                if(velocityY > 0) { velocityY *= -1; }\r\n            }\r\n\r\n            //update the particle\r\n            particle.x = x;\r\n            particle.y = y;\r\n            particle.velocityX = velocityX;\r\n            particle.velocityY = velocityY;\r\n        });\r\n\r\n        //transforming particles to array that delaunator can accept - Object array wrapper\r\n        let particlesForDelaunator = particles.map(particle => {\r\n            return Object.values(particle);\r\n        });\r\n\r\n        //delaunay triangles generated\r\n        const delaunator = Delaunator.from(particlesForDelaunator);\r\n\r\n        //draw triangle on canvas\r\n        let drawTriangle = (i, triangle) => {\r\n            ctx.beginPath();\r\n            ctx.moveTo(triangle[0][0], triangle[0][1]);\r\n            ctx.lineTo(triangle[1][0], triangle[1][1]);\r\n            ctx.lineTo(triangle[2][0], triangle[2][1]);\r\n            ctx.closePath();\r\n\r\n            ctx.fillStyle = generateColor(\r\n                triangle[0][0],\r\n                triangle[0][1],\r\n                triangle[1][0],\r\n                triangle[1][1],\r\n                triangle[2][0],\r\n                triangle[2][1]\r\n            );\r\n\r\n            ctx.shadowColor = triangleShadowColor;\r\n            ctx.shadowBlur = triangleShadowBlur;\r\n            ctx.fill();\r\n\r\n            ctx.strokeStyle = lineColor;\r\n            ctx.lineWidth = lineWidth;\r\n            ctx.stroke();\r\n        };\r\n\r\n        for(let i = 0; i < delaunator.triangles.length / 3; i++) {\r\n            let triangle = pointsOfTriangle(delaunator, i).map(e => particlesForDelaunator[e]);\r\n            drawTriangle(i, triangle);\r\n        }\r\n\r\n        ctx.save();\r\n        //skipping first 4 corner particles\r\n        for(let i = 4; i < particles.length; i++) {\r\n            ctx.fillStyle = particles[i].circleColor;\r\n            ctx.shadowColor = pointShadowColor;\r\n            ctx.shadowBlur = pointShadowBlur;\r\n            ctx.beginPath();\r\n            ctx.arc(particles[i].x, particles[i].y, particles[i].circleSize, 0, Math.PI * 2);\r\n            ctx.closePath();\r\n            ctx.fill();\r\n        };\r\n        ctx.restore();\r\n\r\n        setTimeout(() => {\r\n            requestAnimationFrame(loop);\r\n        }, 1000 / fps);\r\n    };\r\n\r\n    const generateColor = (ax, ay, bx, by, cx, cy) => {\r\n        //triangle center coords\r\n        //const triangleCenterX = (ax + bx + cx) / 3;\r\n        const triangleCenterY = (ay + by + cy) / 3;\r\n\r\n        const percentDistanceFromFloor = triangleCenterY / canvasHeight;\r\n\r\n        //hue saturation lightness\r\n        const hue = valueToPercent(percentDistanceFromFloor, topHue, botHue);\r\n        const sat = valueToPercent(percentDistanceFromFloor, topSat, botSat);\r\n        const lig = valueToPercent(percentDistanceFromFloor, topLig, botLig);\r\n\r\n        return \"#\" + colorConvertor.hsl.hex(hue, sat, lig);\r\n\r\n        // //!!! LEGACY CODE !!!//\r\n        // variations of color calculation:\r\n        // 1) based on triangle area\r\n        // const area = Math.abs(0.5 * (ax*(by - cy) + bx*(cy - ay) + cx*(ay - by)));\r\n        //\r\n        // 2) based on distance from a point (ex. distance from center)\r\n        // const distanceFromCenter = Math.sqrt(\r\n        //     Math.pow(triangleCenterX - canvasWidth / 2, 2) +\r\n        //     Math.pow(triangleCenterY - canvasHeight / 2, 2)\r\n        // );\r\n    };\r\n\r\n    return(\r\n        <div>\r\n            <canvas\r\n                ref = { canvasRef }\r\n                style = {{\r\n                    position: 'absolute',\r\n                    zIndex: -1,\r\n                    width: \"100%\",\r\n                    height: \"100%\"\r\n                }}\r\n\r\n                width = { canvasWidth }\r\n                height = { canvasHeight }\r\n            />\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default Triangulation;","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://cra.link/PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.0/8 are considered localhost for IPv4.\r\n    window.location.hostname.match(/^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/)\r\n);\r\n\r\nexport function register(config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://cra.link/PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl, config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then((registration) => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See https://cra.link/PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch((error) => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl, config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl, {\r\n    headers: { 'Service-Worker': 'script' },\r\n  })\r\n    .then((response) => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then((registration) => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log('No internet connection found. App is running in offline mode.');\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready\r\n      .then((registration) => {\r\n        registration.unregister();\r\n      })\r\n      .catch((error) => {\r\n        console.error(error.message);\r\n      });\r\n  }\r\n}\r\n","const reportWebVitals = onPerfEntry => {\r\n  if (onPerfEntry && onPerfEntry instanceof Function) {\r\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\r\n      getCLS(onPerfEntry);\r\n      getFID(onPerfEntry);\r\n      getFCP(onPerfEntry);\r\n      getLCP(onPerfEntry);\r\n      getTTFB(onPerfEntry);\r\n    });\r\n  }\r\n};\r\n\r\nexport default reportWebVitals;\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport Triangulation from './Triangulation';\r\nimport * as serviceWorkerRegistration from './serviceWorkerRegistration';\r\nimport reportWebVitals from './reportWebVitals';\r\n\r\nReactDOM.render(\r\n  <Triangulation\r\n    //main colors\r\n    topcolor = { \"#221A33\" }\r\n    botcolor = { \"#8A3D99\" }\r\n\r\n    //points settings\r\n    pointscolor = { \"#000000\" }\r\n    mincirclesize = { 3 }\r\n    maxcirclesize = { 8 }\r\n    count = { 100 }\r\n    minspeed = { 0.1 }\r\n    maxspeed = { 0.5 }\r\n    pointshadowblur = { 0 }\r\n    pointshadowcolor = { \"#00000000\" }\r\n\r\n    //point color variation\r\n    colorvariance = { false }\r\n    tint = { 0.5 }\r\n    shade = { 0.7 }\r\n\r\n\r\n    //triangle settings\r\n    triangleshadowblur = { 0 }\r\n    triangleshadowcolor = { \"#00000000\" }\r\n    linewidth = { 1.0 }\r\n    linecolor = { \"#00000000\" }\r\n\r\n    //config\r\n    fps = { 60 }\r\n    backgroundcolor = { \"#00000000\" }\r\n  />,\r\ndocument.getElementById('root'));\r\n\r\n// If you want to start measuring performance in your app, pass a function\r\n// to log results (for example: reportWebVitals(console.log))\r\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\r\nreportWebVitals();\r\n\r\nserviceWorkerRegistration.register();\r\n"],"sourceRoot":""}